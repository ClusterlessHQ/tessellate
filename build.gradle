/*
 * Copyright (c) 2018 Chris K Wensel <chris@wensel.net>. All Rights Reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

buildscript {
  repositories {
    maven {
      url "https://plugins.gradle.org/m2/"
    }
  }
  dependencies {
    classpath "com.github.jengelman.gradle.plugins:shadow:2.0.2"
  }
}

apply plugin: "com.github.johnrengelman.shadow"

apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'idea'
apply plugin: 'eclipse'

apply from: 'etc/dependencyVersions.gradle'
apply from: 'etc/version.gradle'
apply from: "etc/s3Upload.gradle"
apply from: "etc/shadow.gradle"
apply from: 'etc/testing.gradle'

repositories {
  mavenLocal()
  mavenCentral()
  maven {url = 'http://conjars.org/repo/'}
  maven {url = 'https://repository.apache.org'}
}

project.ext.distDir = null

task prepareDist() {
  project.distDir = file( "${rootDir}/build/dist" )
  doLast {
    mkdir( distDir )
  }
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

group = 'io.heretical'
version = releaseVersion

configurations {
  testArtifacts {
    extendsFrom testRuntime
  }
}

dependencies {
  compile group: 'cascading', name: 'cascading-local-s3', version: cascadingLocals3
  compile group: 'cascading', name: 'cascading-local', version: cascadingVersion, changing: true

  compile group: 'net.sf.jopt-simple', name: 'jopt-simple', version: joptVersion

  compile group: 'org.slf4j', name: 'slf4j-api', version: slf4jVersion
  compile group: 'org.slf4j', name: 'slf4j-log4j12', version: slf4jVersion
  compile group: 'log4j', name: 'log4j', version: log4jVersion
  compile group: 'org.slf4j', name: 'slf4j-api', version: slf4jVersion
}

javadoc.dependsOn << prepareDist

javadoc {
  def copyright = '<i>Copyright &#169; 21017 Chris K Wensel. All Rights Reserved.</i>'

  title = "Pointer Path ${releaseVersion}"
  destinationDir = file( "${distDir}/javadoc/${project.name}" )

  failOnError = false

  configure( options ) {
    linkSource = true
    encoding = "UTF8"
    bottom = copyright
    links = [
      'http://docs.oracle.com/javase/7/docs/api/',
      'http://junit.sourceforge.net/javadoc/'
    ]
  }
}

task sourcesJar( type: Jar, dependsOn: classes ) {
  from sourceSets.main.allSource
  classifier = 'sources'
}

task javadocJar( type: Jar, dependsOn: javadoc ) {
  classifier = 'javadoc'
  from javadoc.destinationDir
}

task testsJar( type: Jar, dependsOn: testClasses ) {
  from sourceSets.test.output
  classifier = 'tests'
}

task testSourcesJar( type: Jar, dependsOn: classes ) {
  from sourceSets.test.allSource
  classifier = 'test-sources'
}

artifacts {
  archives jar
  archives sourcesJar
  archives javadocJar
  archives testsJar
  archives testSourcesJar
  testArtifacts testsJar
  testArtifacts testSourcesJar
}

dependencies {
  testCompile group: 'junit', name: 'junit', version: junitVersion
}

test {
  include '**/*Test.class'
  ignoreFailures = !System.getProperty( 'test.haltonerror', "true" ).equals( "true" )
}

assemble.dependsOn << prepareDist

assemble.doLast {

  copy {
    into "${distDir}/lib/${archivesBaseName}"
    from( configurations.compile.resolvedConfiguration.firstLevelModuleDependencies
      .collect {dep ->
      dep.moduleArtifacts.collect {it.file}
    } )
  }

  copy {
    into distDir
    from configurations.default.allArtifacts.files
  }
}

uploadArchives {

  def deployer = repositories.mavenDeployer {
    configuration = configurations.archives

    repository( url: repoUrl ) {
      authentication( userName: repoUserName, password: repoPassword )
    }

    pom.project {
      description 'An API for data management, analytics, and machine learning on parallel computing clusters.'
      inceptionYear '2017'
      url 'http://cascading.org/'
      scm {
        url 'https://github.com/cwensel/cascading-local.git'
      }
      licenses {
        license {
          name 'Mozilla Public License, v. 2.0'
          url 'http://mozilla.org/MPL/2.0/'
          distribution 'repo'
        }
      }
    }
  }
  // make sure test dependencies come first, so that maven isn't getting
  // confused, when reading the generated pom
  [install.repositories.mavenInstaller, deployer]*.pom*.whenConfigured {pom ->
    def scopeOrder = [test: 1, runtime: 2, provided: 3, compile: 4].withDefault {100}
    pom.dependencies = pom.dependencies.sort {scopeOrder[ it.scope ]}
  }
}

task allJavadoc( type: Javadoc, dependsOn: subprojects.javadoc ) {

  def copyright = '<i>Copyright &#169; 2017 Chris K Wensel. All Rights Reserved.</i>'

  title = "Cascading ${releaseVersion}"
  destinationDir = file( "${distDir}/javadoc/all/" )

  source subprojects.javadoc.source
  classpath = rootProject.files( subprojects.javadoc.classpath )

  failOnError = false

  configure( options ) {
    linkSource = true
    encoding = "UTF8"
    bottom = copyright
    links = [
      'http://docs.oracle.com/javase/7/docs/api/',
      'http://junit.sourceforge.net/javadoc/'
    ]
  }
}

task prepareRelease( type: Copy, dependsOn: [':prepareDist', 'project:build', ':allJavadoc'] ) {

  s3UploadDocs.dependsOn << prepareRelease
  s3UploadArtifacts.dependsOn << prepareRelease

  // copy dist and apply any analytics scripts
  def analytics = System.getProperty( 'publish.docs.analytics', '' )

  from "${distDir}/javadoc/"
  into "${s3UploadDocs.source}/javadoc"

  filter {line ->
    line.replaceAll( "</body>", "${analytics}\n</body>" )
  }
}

prepareRelease.doLast {
  logger.info( 'built all artifacts' )
}

task buildDist( dependsOn: prepareRelease ) {
  doLast {
    copy {
      from 'CHANGES.txt'
      from 'README.txt'
      from 'apl.txt'
      from 'LICENSE.txt'
      into distDir
    }
  }
}

task buildPackage( type: Tar, dependsOn: buildDist ) {

  description = "package current build, does not run tests"

  destinationDir = file( s3UploadArtifacts.source )
  baseName = "${rootProject.name}-${releaseVersion}"
  compression = "GZIP"

  into( baseName ) {
    from distDir
  }
}

task buildLatestMeta( dependsOn: buildPackage ) {

  s3UploadArtifacts.dependsOn << buildLatestMeta

  ext.latestArchivePath = null
  ext.latestReleaseTagPath = null
  ext.latestPropertiesPath = null
}

buildLatestMeta.doLast {

  def destination = s3UploadArtifacts.source
  def releaseTar = buildPackage.archivePath.name
  def releaseURL = "http://${s3UploadArtifacts.destination}${releaseTar}"

  latestArchivePath = file( destination, 'latest.txt' )
  latestArchivePath.write( releaseURL )

  latestReleaseTagPath = file( destination, 'latest-tag.txt' )
  latestReleaseTagPath.write( "${releaseTag}" )

  latestPropertiesPath = file( destination, 'latest.properties' )
  latestPropertiesPath.write( "${rootProject.name}.release.version=${releaseVersion}\n" +
    "${rootProject.name}.release.major=${majorVersion}\n" +
    "${rootProject.name}.release.minor=${minorVersion}\n" +
    "${rootProject.name}.release.build=${buildNumber}\n" +
    "${rootProject.name}.release.commit=${currentCommit}\n" +
    "${rootProject.name}.release.tag=${releaseTag}\n" +
    "${rootProject.name}.release.name=${releaseTar}\n" +
    "${rootProject.name}.release.url=${releaseURL}"
  )

  latestJSONPath = file( destination, 'latest.json' )
  latestJSONPath.write( """\
{
  "${rootProject.name}": {
    "release": {
      "name": "${releaseTar}",
      "url": "${releaseURL}",
      "version": "${releaseVersion}",
      "major": "${majorVersion}",
      "minor": "${minorVersion}",
      "build": "${buildNumber}",
      "commit": "${currentCommit}",
      "tag": "${releaseTag}"
    },
    "docs": {
      "userguide": {
        "url": "http://${s3UploadDocs.destination}userguide/"
      },
      "api": {
        "url": "http://${s3UploadDocs.destination}javadoc/",
        "names": [
          "${rootProject.name}-core"
        ]
      }
    }
  }
}"""
  )
}